'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 10 November 2025 at 11:32:07.603467 pm'!Object subclass: #NumeroComplejo	instanceVariableNames: 'real imaginario'	classVariableNames: ''	package: 'Curso-Numeros'!!NumeroComplejo commentStamp: 'LucasIvanBenchatParra 10/11/2025 17:09' prior: 0!"NumeroComplejo" es una clase que sirve para definir e interactuar con números complejos.======================Representación interna======================Clase compuesta por las siguientes variables de instancia:* imaginario: <Object>* real: <Object>===========API Pública===========La clase exporta los siguientes métodos para uso público:	-------	getters	-------	* <<real>>: usado para acceder a la parte real de un número complejo.	* <<imaginario>>: usado para acceder a la parte imaginaria de un número complejo.	-------	setters	-------	* <<real:>>: usado para asignarle un valor a la parte real de un número complejo.	* <<imaginario:>>: usado para asignarle un valor a la parte imaginaria de un número complejo.		-----------------------	Operaciones aritméticas	-----------------------	* <<+>>: utilizada para sumar números complejos.	* <<->>: utilizada para restar números complejos.	* <<*>>: utilizada para multiplicar números complejos.	* <</>>: utilizada para realizar la división decimal de números complejos.	* <<//>>: utilizada para realizar la división entera de números complejos.	* <<**>>: utilizada para realizar la potencia de un número complejo a un exponente N.	* <<cartesianProduct:>>: utilizada para realizar el producto cartesiano de un número complejo.!!NumeroComplejo methodsFor: 'arithmetic' stamp: 'LucasIvanBenchatParra 10/10/2025 23:04'!+ otroComplejo	"Sobreescritura del método '+', específica"	"de esta clase. Se utiliza para sumar números"	"complejos."	| resultado |.	resultado := self class new.	resultado real: self real + otroComplejo real.	resultado imaginario: self imaginario + otroComplejo imaginario.	^resultado.! !!NumeroComplejo methodsFor: 'arithmetic' stamp: 'LucasIvanBenchatParra 10/10/2025 23:05'!cartesianProduct: otroComplejo	"Producto cartesiano entre dos números complejos, con"	"las formas (a + bi) y (c + di)."	"Se devuelve un conjunto con los siguientes productos: "	"(a * c), (a * d), (b * c), (b * d)."	| resultado |.	resultado := OrderedCollection new.	resultado add: self real * otroComplejo real.	resultado add: self real * otroComplejo imaginario.	resultado add: self imaginario * otroComplejo real.	resultado add: self imaginario * otroComplejo imaginario.	^resultado.! !!NumeroComplejo methodsFor: 'arithmetic' stamp: 'LucasIvanBenchatParra 10/10/2025 23:04'!- otroComplejo	"Sobreescritura del método '-', específica"	"de esta clase. Se utiliza para restar números"	"complejos."	| resultado |.	resultado := self class new.	resultado real: self real - otroComplejo real.	resultado imaginario: self imaginario - otroComplejo imaginario.	^resultado.! !!NumeroComplejo methodsFor: 'arithmetic' stamp: 'LucasIvanBenchatParra 10/11/2025 17:03'!** exponent	"Método para devolver la potencia de"	"un número complejo, elevado a la N"	"potencia."	| resultado |.		(exponent isInteger not or: exponent <= 0) ifTrue: [		^self error: 'El exponente de la potencia debe ser un número entero mayor a 0.'	].		resultado := self.		1 to: (exponent - 1) do: [ :i |		resultado := resultado * self.	].		^resultado.! !!NumeroComplejo methodsFor: 'arithmetic' stamp: 'LucasIvanBenchatParra 10/10/2025 23:27'!/ otroComplejo	"Sobreescritura del método '/', específica"	"de esta clase. Se utiliza para realizar la"	"división decimal de números complejos."	""	"Para calcular la parte real se utiliza la"	"siguiente fórmula: (a * c + b * d) / c^2 + d^2"	""	"Para calcular la parte imaginaria se utiliza la"	"siguiente fórmula: ((b * c - a * d) / c^2 + d^2)i"	| resultado denominador nuevo_real nuevo_imaginario |.	denominador := (otroComplejo real * otroComplejo real) + 		(otroComplejo imaginario * otroComplejo imaginario).			(denominador = 0) ifTrue: [ 		^ ZeroDivide signal: 'El denominador en la división es cero (0 + 0i).'	].		resultado := self class new.	nuevo_real := (self real * otroComplejo real) +		(self imaginario * otroComplejo imaginario).	nuevo_imaginario := (self imaginario * otroComplejo real) -		(self real * otroComplejo imaginario).	resultado real: nuevo_real / denominador.	resultado imaginario: nuevo_imaginario / denominador.	^resultado.! !!NumeroComplejo methodsFor: 'arithmetic' stamp: 'LucasIvanBenchatParra 10/11/2025 00:04'!// otroComplejo	"Sobreescritura del método '//', específica"	"de esta clase. Se utiliza para realizar la"	"división entera de números complejos."	""	"Para realizar esta división primero se realiza"	"la división decimal y luego se redondean los"	"elementos del número resultante con la"	"operación '// 1'."	| numero resultado |.	numero := self / otroComplejo.	resultado := self class new.	resultado real: numero real // 1.	resultado imaginario: numero imaginario // 1.	^resultado.! !!NumeroComplejo methodsFor: 'arithmetic' stamp: 'LucasIvanBenchatParra 10/10/2025 20:18'!* otroComplejo	"Sobreescritura del método '*', específica de esta"	"clase. Se utiliza para realizar el producto de"	"números complejos."		"El producto de números complejos tiene la forma: "	"(a + bi) * (c + di) = (ac − bd) + (ad + bc)i."	| resultado resta suma |	resultado := self class new.	resta := (self real * otroComplejo real) - (self imaginario * otroComplejo imaginario).	suma := (self real * otroComplejo imaginario) + (self imaginario * otroComplejo real).		resultado real: resta.	resultado imaginario: suma.	^resultado.! !!NumeroComplejo methodsFor: 'initialization' stamp: 'LucasIvanBenchatParra 10/10/2025 01:18'!initialize	"Inicialización de los atributos de la clase"	"con valores por defecto lógicos."	super initialize.	real := 0.	imaginario := 0.! !!NumeroComplejo methodsFor: 'setting' stamp: 'LucasIvanBenchatParra 10/10/2025 01:54'!real: numeroReal	"Método para asignarle un valor a la parte real de un número complejo."	self checkNumber: numeroReal.	real := numeroReal.! !!NumeroComplejo methodsFor: 'setting' stamp: 'LucasIvanBenchatParra 10/10/2025 01:52'!imaginario: numeroImaginario	"Método para asignarle un valor a la parte imaginaria de un número complejo."	self checkNumber: numeroImaginario.	imaginario := numeroImaginario.! !!NumeroComplejo methodsFor: 'accessing' stamp: 'LucasIvanBenchatParra 10/9/2025 18:28'!real	"Método para devolver la parte real de un número complejo."	^real.! !!NumeroComplejo methodsFor: 'accessing' stamp: 'LucasIvanBenchatParra 10/9/2025 18:28'!imaginario	"Método para devolver la parte imaginaria de un número complejo."	^imaginario.! !!NumeroComplejo methodsFor: 'printing' stamp: 'LucasIvanBenchatParra 10/16/2025 19:46'!printOn: aStream	"Sobreescritura del método printOn, específica	de esta clase."	""	"Se lo sobreescribe con la finalidad de mostrar	el valor de los atributos de la clase cuando se	inspecciona un objeto."	""	"Téngase en cuenta que para imprimir caracteres	debe usarse el método nextPut, no nextPutAll, ya	que sino el intérprete de Smalltalk se queja."	aStream nextPut: $(.	aStream nextPutAll: self real asString.		(self imaginario >= 0)		ifTrue: [ aStream nextPutAll: ' + ' ]		ifFalse: [			"Si el número es negativo, se lo reemplaza"			"por su valor absoluto para luego imprimir"			"un signo menos por pantalla y que no se"			"choque con el signo propio del número."			imaginario := imaginario abs.			aStream nextPutAll: ' - '.		].	aStream nextPutAll: self imaginario asString.	aStream nextPut: $i.	aStream nextPut: $).! !!NumeroComplejo methodsFor: 'private' stamp: 'LucasIvanBenchatParra 10/10/2025 19:15'!checkNumber: num	"Método privado diseñado para los métodos de la"	"categoría 'setting'. Se utiliza para asegurarse"	"de que únicamente se introduzcan números válidos"	"en los atributos con los setters."	| nil_err_msg nan_err_msg |.	nil_err_msg := 'Debe introducirse un número, no un espacio vacío'.	nan_err_msg := 'Debe introducirse un número, no una letra o un símbolo.'.		num ifNil: [ ^self error: nil_err_msg ].		(num isNumber)		ifFalse: [ ^self error: nan_err_msg ].! !